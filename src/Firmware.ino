#include <NTPClient.h>
#include <WiFiUdp.h>

//#include <HardwareSerial.h>
//HardwareSerial SerialPort2 (2);
const byte txPin = 17;
const byte rxPin = 18;

// Define NTP Client to get time
WiFiUDP ntpUDP;

// Version Info
String BetaGoldhen = "GoldHEN v2.4b17";
String fwversion = "v1.06 (Final)";

// Variables to save date and time
String formattedDate;
String dayStamp;
String timeStamp;
int GMT = (1*3600)-3600;
// GMT +1 = 3600
//GMT -1 = -3600
NTPClient timeClient(ntpUDP, "europe.pool.ntp.org", GMT, 30000);
//

#define TFT_W 160 //set tft screen width
#define TFT_H 80 //set tft screen height

unsigned long startMillis;  //some global variables available anywhere in the program
unsigned long start2Millis;  //global for scrolling text
unsigned long start3Millis;
unsigned long currentMillis;
unsigned long nowMillis;

int8_t tcount;
boolean mounted = false;
boolean colour_cycle = true; //set true so when power is applied the onboard led starts colour cycling
boolean blink_led = false; //trigger when usb is enabled
boolean scroller = false; //enable scrolling text on the tft screen
boolean runonce = true; //don't change this
boolean resetconf = false; //don't change this
String mcuType = CONFIG_IDF_TARGET;
String ip; //used for lcd screen info
String sid; //used for lcd screen info
boolean psphive = false; //automatically divert index.html to index2.html
String selfserver; //for psphive to check if we are using access point or wifi mode
boolean installgoldhen = false; //install default goldhen to filesys if hard reset is activated
String strusw;
//String lcdscroller = "";
String lcdscroller[] PROGMEM = {""};
static const uint16_t randrange[] PROGMEM = {0x07BF, 0x0FE0, 0xFB00, 0x079F, 0xFFFF, 0xF818, 0x2FE0, 0x9FE0}; //create and array that only allows certain colours
boolean rotate_lcd = false;
boolean use_psfree = true;
boolean use_beta_goldhen = false;
boolean lightsdelay = false;
boolean hardformat = true;

//star stuff
#define STARS 20 //amount of stars to show on screen
float star_x[STARS], star_y[STARS], star_z[STARS];
uint8_t scroll_loc = 28; //starting height to push the scroll sprite to
int8_t starx,stary;
int8_t swap_routine = 0;
int8_t routine = 0;
int8_t jump = 0;

//fire stuff
#define MAXPAL 1
uint16_t matrix[16384 + TFT_W];
uint16_t backBuffer565[16384];
uint16_t color[400]; // 2 palettes and current pallet space.
uint8_t pallet = 1;
uint8_t maxPal = 0;
uint32_t XORRand = 0;
boolean fire_effect = false;

#include <OneButton.h>
#include <FS.h>
#include "WiFi.h"
#include "ESPAsyncWebServer.h"
#include "esp_task_wdt.h"
#include <DNSServer.h>
#include <ESPmDNS.h>
#include <Update.h>
#include "USB.h"
#include "USBMSC.h"
//mounting sd card files start
#include "driver/sdmmc_host.h"
#include "driver/sdspi_host.h"
#include "esp_vfs_fat.h"
#include "sdmmc_cmd.h"
#define MOUNT_POINT "/sdcard"
sdmmc_card_t *card;
const char mount_point[] = MOUNT_POINT;
//mounting sd card files end
#define usepico false //use popup exfathax
#if usepico
#include "exfatPico.h"
#else
#include "exfathax.h"
#endif
#include "loader_psfree.h"
#include "exploit_psfree.h"
#include "loader_old.h"
#include "jzip.h"
#include "logo.h"
#define usefat true  //use fat partition instead of spiffs
#if usefat
#include "FFat.h"
#define FILESYS FFat
#else
//#include "SPIFFS.h"
//#define FILESYS SPIFFS
#endif
#include "goldhen.h"
#include "stable_goldhen.h"
#include "pages.h"
#include <FastLED.h> // https://github.com/FastLED/FastLED
#include "TFT_eSPI.h"
#include "pin_config.h" //include pins for Lilygo Tdongle-S3
#include "cache.h"

//unpacking stuff
#if usefat
#define DEST_FS_USES_FFAT
#else
#define DEST_FS_USES_SPIFFS
#endif
//#define DEST_FS_USES_SD
//#define DEST_FS_USES_SD_MMC
//#define DEST_FS_USES_LITTLEFS
#include <ESP32-targz.h>

//Telegram bot stuff
boolean UseTG = false;
boolean UseTGBot = false;
uint8_t Bot_mode = 1; //don't change to zero
String BOTtoken = ""; //for telegram
String CHAT_ID = ""; //for telegram
#include <WiFiClientSecure.h>
#include <UniversalTelegramBot.h>
#include <ArduinoJson.h>
WiFiClientSecure client;
UniversalTelegramBot bot(BOTtoken, client);
// Checks for new messages every 1 second.
const uint16_t botRequestDelay = 1000;
uint8_t message_status = 0;
unsigned long lastTimeBotRan;
uint8_t numNewMessages = 0;
//end of bot stuff

CRGB leds;
TFT_eSPI tft = TFT_eSPI();
TFT_eSprite stext2 = TFT_eSprite(&tft); // Sprite object stext2
OneButton button(BTN_PIN, true);
uint8_t btn_press = 0;
uint16_t arraypos = 0; //Start char for scroller
uint16_t changecol = 0;

static const char compile_date[] PROGMEM = {__DATE__};

//set a default payload for payloads.html config page
String Default_Payload = "goldhen.bin"; //don't change unless you also mod pages.h/payload code
String Payload_Name = "GoldHEN"; //don't change unless you also mod pages.h/payload code

//create access point
boolean startAP = true;
String AP_SSID = "PS4-Hack";
String AP_PASS = "";
IPAddress Server_IP(1, 2, 3, 4);
IPAddress Subnet_Mask(255, 255, 255, 0);

//connect to wifi
boolean connectWifi = false;
String WIFI_SSID = "your_ssid";
String WIFI_PASS = "your_pass";
String WIFI_HOSTNAME = "PS4-Local";

//server port
int8_t WEB_PORT = 80;

//Auto Usb Wait(milliseconds)
int16_t USB_WAIT = 3000; //don't change unless you also mod pages.h payload

//ESP sleep after x minutes
boolean espSleep = true; //enable on by default
boolean sleeponpayload = false; //deepsleep after payload is sent
int8_t TIME2SLEEP = 10; // minutes
//-----------------------------------------------------//

DNSServer dnsServer;
AsyncWebServer server(WEB_PORT);
boolean isFormating = false;
long bootTime = 0;
File upFile;
USBMSC dev;

String split(String str, String from, String to) {
  //str.toLowerCase();
  //from.toLowerCase();
  //to.toLowerCase();
  int pos1 = str.indexOf(from);
  int pos2 = str.indexOf(to, pos1 + from.length());
  String retval = str.substring(pos1 + from.length(), pos2);
  return retval;
}

bool instr(String str, String search) {
  int result = str.indexOf(search);
  if (result == -1) {
    return false;
  }
  return true;
}

String formatBytes(size_t bytes) {
  if (bytes < 1024) {
    return String(bytes) + " B";
  } else if (bytes < (1024 * 1024)) {
    return String(bytes / 1024.0) + " KB";
  } else if (bytes < (1024 * 1024 * 1024)) {
    return String(bytes / 1024.0 / 1024.0) + " MB";
  } else {
    return String(bytes / 1024.0 / 1024.0 / 1024.0) + " GB";
  }
}

//convert byte array to a hex string output
String mac2String(byte ar[]){
  String s;
  for (byte i = 0; i <= 5; ++i)
  {
    char buf[3];
    sprintf(buf, "%02X", ar[i]);
    s += buf;
    if (i <= 4) s += ':';
  }
  return s;
}

//get esp2 mac address from long long int and convert into a byte array
String MacAddress() {
  uint64_t mac = ESP.getEfuseMac();
  char arrayOfByte[]={};
  memcpy(arrayOfByte, &mac, 6);
  char one = arrayOfByte[0];
  char two = arrayOfByte[1];
  char three = arrayOfByte[2];
  char four = arrayOfByte[3];
  char five = arrayOfByte[4];
  char six = arrayOfByte[5];
  byte buf[] = {one, two, three, four, five, six};
  String s = mac2String(buf);
  return (s);
}

String chipID(){
  return (String(ESP.getEfuseMac()));
}

String urlencode(String str) {
  String encodedString = "";
  char c;
  char code0;
  char code1;
  char code2;
  for (int i = 0; i < str.length(); i++) {
    c = str.charAt(i);
    if (c == ' ') {
      encodedString += '+';
    } else if (isalnum(c)) {
      encodedString += c;
    } else {
      code1 = (c & 0xf) + '0';
      if ((c & 0xf) > 9) {
        code1 = (c & 0xf) - 10 + 'A';
      }
      c = (c >> 4) & 0xf;
      code0 = c + '0';
      if (c > 9) {
        code0 = c - 10 + 'A';
      }
      code2 = '\0';
      encodedString += '%';
      encodedString += code0;
      encodedString += code1;
    }
    yield(); //https://www.arduino.cc/reference/en/libraries/scheduler/yield/
  }
  encodedString.replace("%2E", ".");
  return encodedString;
}

void sendwebmsg(AsyncWebServerRequest * request, String htmMsg) {
  String tmphtm = "<!DOCTYPE html><html><head><link rel=\"stylesheet\" href=\"style.css\"></head><center><br><br><br><br><br><br>" + htmMsg + "</center></html>";
  request -> send(200, "text/html", tmphtm);
}

void handleFwUpdate(AsyncWebServerRequest * request, String filename, size_t index, uint8_t * data, size_t len, bool final) {
  if (!index) {
    String path = request -> url();
    if (path != "/update.html") {
      request -> send(500, "text/plain", "Internal Server Error");
      return;
    }
    if (!filename.equals("fwupdate.bin")) {
      sendwebmsg(request, "Invalid update file: " + filename);
      return;
    }
    if (!filename.startsWith("/")) {
      filename = "/" + filename;
    }
    if (!Update.begin((ESP.getFreeSketchSpace() - 0x1000) & 0xFFFFF000)) {
      //Update.printError(Serial);
      sendwebmsg(request, "Update Failed: " + String(Update.errorString()));
    }
  }
  if (!Update.hasError()) {
    if (Update.write(data, len) != len) {
      //Update.printError(Serial);
      sendwebmsg(request, "Update Failed: " + String(Update.errorString()));
    }
  }
  if (final) {
    if (Update.end(true)) {
      request -> send(200, "text/html", ("%s", bigstrings[0]));
      delay(500);
      ESP.restart();
    } else {
      //Update.printError(Serial);
    }
  }
}

void handleDelete(AsyncWebServerRequest * request) {
  if (!request -> hasParam("file", true)) {
    request -> redirect("/fileman.html");
    return;
  }
  String path = request -> getParam("file", true) -> value();
  if (path.length() == 0) {
    request -> redirect("/fileman.html");
    return;
  }
  if (FILESYS.exists("/" + path) && path != "/" && !path.equals("config.ini")) {
    FILESYS.remove("/" + path);
  }
  request -> redirect("/fileman.html");
}

void handleFileMan(AsyncWebServerRequest *request) {
  File dir = FILESYS.open("/");
  String output = "<!DOCTYPE html><html><head><meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"><title>File Manager</title><link rel=\"stylesheet\" href=\"style.css\"><style>body{overflow-y:auto;} th{border: 1px solid #dddddd; background-color:gray;padding: 8px;}</style><script>function statusDel(fname) {var answer = confirm(\"Are you sure you want to delete \" + fname + \" ?\");if (answer) {return true;} else { return false; }} </script></head><body><br><table id=filetable></table><script>var filelist = [";
  int fileCount = 0;
  while (dir) {
    File file = dir.openNextFile();
    if (!file) {
      dir.close();
      break;
    }
    String fname = String(file.name());
    if (fname.length() > 0 && !fname.equals("config.ini") && !file.isDirectory()) {
      fileCount++;
      fname.replace("|", "%7C");
      fname.replace("\"", "%22");
      output += "\"" + fname + "|" + formatBytes(file.size()) + "\",";
    }
    file.close();
    esp_task_wdt_reset();
  }
  if (fileCount == 0) {
    output += "];</script><center>No files found<br>You can upload files using the <a href=\"/upload.html\" target=\"mframe\"><u>File Uploader</u></a> page.</center></p></body></html>";
  } else {
    output += "];var output = \"\";filelist.forEach(function(entry) {var splF = entry.split(\"|\"); output += \"<tr>\";output += \"<td><a href=\\\"\" +  splF[0] + \"\\\">\" + splF[0] + \"</a></td>\"; output += \"<td>\" + splF[1] + \"</td>\";output += \"<td><center><a href=\\\"/\" + splF[0] + \"\\\" download><button type=\\\"submit\\\">Download</button></a></td></center>\";output += \"<td><center><form action=\\\"/delete\\\" method=\\\"post\\\"><button type=\\\"submit\\\" name=\\\"file\\\" value=\\\"\" + splF[0] + \"\\\" onClick=\\\"return statusDel('\" + splF[0] + \"');\\\">Delete</button></center></form></td>\";output += \"</tr>\";}); document.getElementById(\"filetable\").innerHTML = \"<tr><th colspan='1'><center>File Name</center></th><th colspan='1'><center>File Size</center></th><th colspan='1'><center><a href='/dlall' target='mframe'><button type='submit'>Download All</button></a></center></th><th colspan='1'><center><a href='/wipe' target='mframe'><button type='submit'>Delete All</button></a></center></th></tr>\" + output;</script></body></html>";
  }
  request->send(200, "text/html", output);
}

void handleDlFiles(AsyncWebServerRequest * request) {
  File dir = FILESYS.open("/");
  String output = "<!DOCTYPE html><html><head><meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"><title>File Downloader</title><link rel=\"stylesheet\" href=\"style.css\"><style>body{overflow-y:auto;}</style><script type=\"text/javascript\" src=\"jzip.js\"></script><script>var filelist = [";
  int16_t fileCount = 0;
  while (dir) {
    File file = dir.openNextFile();
    if (!file) {
      dir.close();
      break;
    }
    String fname = String(file.name());
    if (fname.length() > 0 && !fname.equals("config.ini") && !file.isDirectory()) {
      fileCount++;
      fname.replace("\"", "%22");
      output += "\"" + fname + "\",";
    }
    file.close();
    esp_task_wdt_reset();
  }
  if (fileCount == 0) {
    output += "];</script></head><center>No files found to download<br>You can upload files using the <a href=\"/upload.html\" target=\"mframe\"><u>File Uploader</u></a> page.</center></p></body></html>";
  } else {
    output += "]; async function dlAll(){var zip = new JSZip();for (var i = 0; i < filelist.length; i++) {if (filelist[i] != ''){var xhr = new XMLHttpRequest();xhr.open('GET',filelist[i],false);xhr.overrideMimeType('text/plain; charset=x-user-defined'); xhr.onload = function(e) {if (this.status == 200) {zip.file(filelist[i], this.response,{binary: true});}};xhr.send();document.getElementById('fp').innerHTML = 'Adding: ' + filelist[i];await new Promise(r => setTimeout(r, 50));}}document.getElementById('gen').style.display = 'none';document.getElementById('comp').style.display = 'block';zip.generateAsync({type:'blob'}).then(function(content) {saveAs(content,'esp_files.zip');});}</script></head><body onload='setTimeout(dlAll,100);'><center><br><br><br><br><div id='gen' style='display:block;'><div id='loader'></div><br><br>Generating ZIP<br><p id='fp'></p></div><div id='comp' style='display:none;'><br><br><br><br>Complete<br><br>Downloading: esp_files.zip</div></center></body></html>";
  }
  request -> send(200, "text/html", output);
}

void handleConfig(AsyncWebServerRequest * request) {
  if (request -> hasParam("ap_ssid", true) && request -> hasParam("ap_pass", true) && request -> hasParam("web_ip", true) && request -> hasParam("web_port", true) && request -> hasParam("subnet", true) && request -> hasParam("wifi_ssid", true) && request -> hasParam("wifi_pass", true) && request -> hasParam("wifi_host", true) && request -> hasParam("usbwait", true) && request -> hasParam("payload", true) && request -> hasParam("bot_token", true) && request -> hasParam("chat_id", true)) {
    AP_SSID = request -> getParam("ap_ssid", true) -> value();
    if (!request -> getParam("ap_pass", true) -> value().equals("********")) {
      AP_PASS = request -> getParam("ap_pass", true) -> value();
    }
    WIFI_SSID = request -> getParam("wifi_ssid", true) -> value();
    if (!request -> getParam("wifi_pass", true) -> value().equals("********")) {
      WIFI_PASS = request -> getParam("wifi_pass", true) -> value();
    }
    String tmpip = request -> getParam("web_ip", true) -> value();
    String tmpwport = request -> getParam("web_port", true) -> value();
    String tmpsubn = request -> getParam("subnet", true) -> value();
    String WIFI_HOSTNAME = request -> getParam("wifi_host", true) -> value();
    String Default_Payload = request -> getParam("payload", true) -> value();
    String Payload_Name = request -> getParam("payload_name", true) -> value();
    String BOTtoken = request -> getParam("bot_token", true) -> value();
    String CHAT_ID = request -> getParam("chat_id", true) -> value();
    String tmpua = "false";
    String tmpcw = "false";
    String tmpslp = "false";
    String pysleep = "false";
    String ps_phive = "false";
    String rotate = "false";
    String psfree = "false";
    String betaGH = "false";
    String telegram = "false";
    String botcommands = "false";
    if (request -> hasParam("useap", true)) {
      tmpua = "true";
    }
    if (request -> hasParam("usewifi", true)) {
      tmpcw = "true";
    }
    if (request -> hasParam("use_telgram", true)) {
      telegram = "true";
    }
    if (request -> hasParam("use_botcommands", true)) {
      botcommands = "true";
    }
    if (request -> hasParam("espsleep", true)) {
      tmpslp = "true";
    }
    if (request -> hasParam("sleeponpayload", true)) {
      pysleep = "true";
    }
    if (request -> hasParam("redirect", true)) {
      ps_phive = "true";
    }
    if (request -> hasParam("Rotscreen", true)) {
      rotate = "true";
    }
    if (request -> hasParam("PSFree", true)) {
      psfree = "true";
    }
    if (request -> hasParam("betaGH", true)) {
      betaGH = "true";
    }
    if (tmpua.equals("false") && tmpcw.equals("false")) {
      tmpua = "true";
    }
    int USB_WAIT = request -> getParam("usbwait", true) -> value().toInt();
    int TIME2SLEEP = request -> getParam("sleeptime", true) -> value().toInt();
    File iniFile = FILESYS.open("/config.ini", "w");
    if (iniFile) {
      iniFile.print("AP_SSID=" + AP_SSID + "\r\nAP_PASS=" + AP_PASS + "\r\nWEBSERVER_IP=" + tmpip + "\r\nWEBSERVER_PORT=" + tmpwport + "\r\nSUBNET_MASK=" + tmpsubn + "\r\nWIFI_SSID=" + WIFI_SSID + "\r\nWIFI_PASS=" + WIFI_PASS + "\r\nWIFI_HOST=" + WIFI_HOSTNAME + "\r\nUSEAP=" + tmpua + "\r\nCONWIFI=" + tmpcw + "\r\nUSBWAIT=" + USB_WAIT + "\r\nESPSLEEP=" + tmpslp + "\r\nSLEEPTIME=" + TIME2SLEEP + "\r\npayload=" + Default_Payload + "\r\npayload_name=" + Payload_Name + "\r\nbot_token=" + BOTtoken + "\r\nchat_id=" + CHAT_ID + "\r\nUseTelegram=" + telegram + "\r\nUseTelegramCom=" + botcommands + "\r\nPayloadSleep=" + pysleep + "\r\nRedirect=" + ps_phive + "\r\nRotscreen=" + rotate + "\r\nPSFree=" + psfree + "\r\nbetaGH=" + betaGH);
      iniFile.close();
    }

    //refreshing page to index.html instead of config.html will force ps-phive to reinstall cached files.
    request -> send(200, "text/html", ("%s", bigstrings[1]));
    writepage(); //needs esp32 s2 to reboot before it takes effect!

    delay(1000);
    ESP.restart();
  }
}

void handleReboot(AsyncWebServerRequest * request) {
  AsyncWebServerResponse * response = request -> beginResponse_P(200, "text/html", rebooting_gz, sizeof(rebooting_gz));
  response -> addHeader("Content-Encoding", "gzip");
  request -> send(response);
  delay(1000);
  ESP.restart();
}

void handleConfigHtml(AsyncWebServerRequest * request) {
  String tmpUa = "";
  String tmpCw = "";
  String tmpSlp = "";
  String pysleep = "";
  String telegram = "";
  String botcommands = "";
  String ps_phive = "";
  String rotate = "";
  String psfree = "";
  String betaGH = "";
  if (startAP) {
    tmpUa = "checked";
  }
  if (connectWifi) {
    tmpCw = "checked";
  }

  if (UseTG) {
    telegram = "checked";
  }

  if (UseTGBot) {
    botcommands = "checked";
  }

  if (espSleep) {
    tmpSlp = "checked";
  }

  if (sleeponpayload) {
    pysleep = "checked";
  }

  if (psphive) {
    ps_phive = "checked";
  }

  if (rotate_lcd) {
    rotate = "checked";
  }

  if (use_psfree) {
    psfree = "checked";
  }

  if (use_beta_goldhen) {
    betaGH = "checked";
  }

  String htmStr = "<!DOCTYPE html><html><head><meta http-equiv=\"Cache-control\" content=\"no-cache\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"><title>Config Editor</title><style type=\"text/css\">body {background: rgb(2,0,36);background: linear-gradient(90deg, rgba(2,0,36,1) 0%, rgba(9,9,121,1) 35%, rgba(0,212,255,1) 100%); color: #ffffff; font-size: 14px;font-weight: bold;margin: 0 0 0 0.0;padding: 0.4em 0.4em 0.4em 0.6em;}input[type=\"submit\"]:hover {background: #ffffff;color: green;}input[type=\"submit\"]:active{outline-color: green;color: green;background: #ffffff; }table {font-family: arial, sans-serif;border-collapse: collapse;}td {border: 1px solid #dddddd;text-align: left;padding: 8px;}th {border: 1px solid #dddddd; background-color:gray;text-align: center;padding: 8px;}</style></head><body><form action=\"/config.html\" method=\"post\"><center><table><tr><th colspan=\"2\"><center>Access Point</center></th></tr><tr><td>AP SSID:</td><td><input name=\"ap_ssid\" value=\"" + AP_SSID + "\"></td></tr><tr><td>AP Password:</td><td><input name=\"ap_pass\" value=\"********\"></td></tr><tr><td>AP IP:</td><td><input name=\"web_ip\" value=\"" + Server_IP.toString() + "\"></td></tr><tr><td>Subnet Mask:</td><td><input name=\"subnet\" value=\"" + Subnet_Mask.toString() + "\"></td></tr><tr><td>Start AP:</td><td><input type=\"checkbox\" name=\"useap\" " + tmpUa + "></td></tr><tr><th colspan=\"2\"><center>Web Server</center></th></tr><tr><td>Webserver Port:</td><td><input name=\"web_port\" value=\"" + String(WEB_PORT) + "\"></td></tr><tr><th colspan=\"2\"><center>Wifi Connection</center></th></tr><tr><td>Wifi SSID:</td><td><input name=\"wifi_ssid\" value=\"" + WIFI_SSID + "\"></td></tr><tr><td>Wifi Password:</td><td><input name=\"wifi_pass\" value=\"********\"></td></tr><tr><td>Wifi Hostname:</td><td><input name=\"wifi_host\" value=\"" + WIFI_HOSTNAME + "\"></td></tr><tr><td>Connect Wifi:</td><td><input type=\"checkbox\" name=\"usewifi\" " + tmpCw + "></td></tr><tr><th colspan=\"2\"><center>Telegram Bot</center></th></tr><tr><td>Bot Token:</td><td><input name=\"bot_token\" value=\"" + BOTtoken + "\"></td></tr><tr><td>Chat ID:</td><td><input name=\"chat_id\" value=\"" + CHAT_ID + "\"></td></tr><tr><td>Enable Bot:</td><td><input type=\"checkbox\" name=\"use_telgram\" " + telegram + "></td></tr><tr><td>Enable Bot Commands:</td><td><input type=\"checkbox\" name=\"use_botcommands\" " + botcommands + "></td></tr><tr><tr><th colspan=\"2\"><center>Auto USB Wait</center></th></tr><tr><td>Wait Time(ms):</td><td><input name=\"usbwait\" value=\"" + USB_WAIT + "\"></td></tr><tr><th colspan=\"2\"><center>ESP Sleep Mode</center></th></tr><tr><td>Enable Sleep:</td><td><input type=\"checkbox\" name=\"espsleep\" " + tmpSlp + "></td></tr><tr><td>After Payload Injection:</td><td><input type=\"checkbox\" name=\"sleeponpayload\" " + pysleep + "></td></tr><tr><td>Sleep Delay(minutes):</td><td><input name=\"sleeptime\" value=\"" + TIME2SLEEP + "\"></td></tr><tr><th colspan=\"2\"><center>Default Payload</center></th></tr><tr><td>Default Payload Name:</td><td><input name=\"payload_name\" value=\"" + Payload_Name + "\"></td></tr><tr><td>Payload Bin:</td><td><input name=\"payload\" value=\"" + Default_Payload + "\"></td></tr><tr><td>Use " + BetaGoldhen + ":</td><td><input type=\"checkbox\" name=\"betaGH\" " + betaGH + "></td></tr><th colspan=\"2\"><center>Redirect Payload Loader to Index2.html</center></th></tr><tr><td>Redirect:</td><td><input type=\"checkbox\" name=\"redirect\" " + ps_phive + "></td></tr><th colspan=\"2\"><center>Rotate LCD Display</center></th></tr><tr><td>Rotate:</td><td><input type=\"checkbox\" name=\"Rotscreen\" " + rotate + "></td></tr><th colspan=\"2\"><center>Use PSFree</center></th></tr><tr><td>PSFree:</td><td><input type=\"checkbox\" name=\"PSFree\" " + psfree + "></td></tr></table><br><input id=\"savecfg\" type=\"submit\" value=\"Save Config\"></center></form></body></html>";
  request -> send(200, "text/html", htmStr);
}

void handleFileUpload(AsyncWebServerRequest * request, String filename, size_t index, uint8_t * data, size_t len, bool final) {
  if (!index) {
    String path = request -> url();
    if (path != "/upload.html") {
      request -> send(500, "text/plain", "Internal Server Error");
      return;
    }
    if (!filename.startsWith("/")) {
      filename = "/" + filename;
    }
    if (filename.equals("/config.ini")) {
      return;
    }
    upFile = FILESYS.open(filename, "w");
  }
  if (upFile) {
    upFile.write(data, len);
  }
  if (final) {
    upFile.close();
  }
}

void handleInfo(AsyncWebServerRequest * request) {
  float flashFreq = (float) ESP.getFlashChipSpeed() / 1000.0 / 1000.0;
  FlashMode_t ideMode = ESP.getFlashChipMode();
  String output = "<!DOCTYPE html><html><head><meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"><title>System Information</title><style type=\"text/css\">body { background: rgb(2,0,36);background: linear-gradient(90deg, rgba(2,0,36,1) 0%, rgba(9,9,121,1) 35%, rgba(0,212,255,1) 100%);color: #ffffff;font-size: 14px;font-weight: bold; margin: 0 0 0 0.0; padding: 0.4em 0.4em 0.4em 0.6em;}</style></head>";
  output += "<hr><center><p>*** Code Mod By MrDude ***</center>";
  output += "<hr>###### MCU information ######<br><br>";
  output += "MCU: " + mcuType + "<br>";
  output += "Firmware version " + fwversion + "<br>";
  output += "SDK version: " + String(ESP.getSdkVersion()) + "<br>";
  output += "MAC Address: " + MacAddress() + "<br>";
  output += "Cycle Count: " + String(ESP.getCycleCount()) + "<br><hr>";
  output += "###### CPU ######<br><br>";
  output += "Chip Id: " + String(ESP.getChipModel()) + "<br>";
  output += "CPU frequency: " + String(ESP.getCpuFreqMHz()) + "MHz<br>";
  output += "Chip Revision: " + String(ESP.getChipRevision()) + "<br>";
  output += "Cores: " + String(ESP.getChipCores()) + "<br><hr>";
  output += "###### Flash chip information ######<br><br>";
  output += "Flash chip Id: " + chipID() + "<br>";
  output += "Estimated Flash size: " + formatBytes(ESP.getFlashChipSize()) + "<br>";
  output += "Flash frequency: " + String(flashFreq) + " MHz<br>";
  output += "Flash write mode: " + String((ideMode == FM_QIO ? "QIO" : ideMode == FM_QOUT ? "QOUT" : ideMode == FM_DIO ? "DIO" : ideMode == FM_DOUT ? "DOUT" : "UNKNOWN")) + "<br><hr>";

  if (usefat == true) {
    output += "###### File system (FatFs) ######<br><br>";
  }
  else {
    output += "###### File system (SPIFFS) ######<br><br>";
  }
  output += "Total Size: " + formatBytes(FILESYS.totalBytes()) + "<br>";
  output += "Used Space: " + formatBytes(FILESYS.usedBytes()) + "<br>";
  output += "Free Space: " + formatBytes(FILESYS.totalBytes() - FILESYS.usedBytes()) + "<br><hr>";
  //There's no PSRAM on this board so there's no point showing this information....
  /*
  output += "###### PSRam information ######<br><br>";
  output += "Psram Size: " + formatBytes(ESP.getPsramSize()) + "<br>";
  output += "Free psram: " + formatBytes(ESP.getFreePsram()) + "<br>";
  output += "Max alloc psram: " + formatBytes(ESP.getMaxAllocPsram()) + "<br><hr>";
  */
  output += "###### Ram information ######<br><br>";
  output += "Ram size: " + formatBytes(ESP.getHeapSize()) + "<br>";
  output += "Free ram: " + formatBytes(ESP.getFreeHeap()) + "<br>";
  output += "Min free ram since boot: " + formatBytes(ESP.getMinFreeHeap()) + "<br>";
  output += "Max alloc ram: " + formatBytes(ESP.getMaxAllocHeap()) + "<br><hr>";
  output += "###### Sketch information ######<br><br>";
  output += "Build date: " + String(compile_date) + "<br>";
  output += "Sketch hash: " + ESP.getSketchMD5() + "<br>";
  output += "Sketch size: " + formatBytes(ESP.getSketchSize()) + "<br>";
  output += "Free space available: " + formatBytes(ESP.getFreeSketchSpace() - ESP.getSketchSize()) + "<br><hr>";
  output += "<center><p>*** Greetings to all the scene hackers out there ***</center><hr>";
  output += "</html>";
  request -> send(200, "text/html", output);
}

void writeConfig() {
  File iniFile = FILESYS.open("/config.ini", "w");
  if (iniFile) {
    String tmpua = "false";
    String tmpcw = "false";
    String tmpslp = "false";
    String pysleep = "false";
    String ps_phive = "false";
    String rotate = "false";
    String psfree = "false";
    String betaGH = "false";
    String telegram = "false";
    String botcommands = "false";
    if (startAP) {
      tmpua = "true";
    }
    if (connectWifi) {
      tmpcw = "true";
    }
    if (UseTG) {
      telegram = "true";
    }
    if (UseTGBot) {
      botcommands = "true";
    }
    if (espSleep) {
      tmpslp = "true";
    }
    if (sleeponpayload) {
      pysleep = "true";
    }
    if (psphive) {
      ps_phive = "true";
    }
    if (rotate_lcd) {
      rotate = "true";
    }
    if (use_psfree) {
      psfree = "true";
    }
    if (use_beta_goldhen) {
      betaGH = "true";
    }
    iniFile.print("AP_SSID=" + AP_SSID + "\r\nAP_PASS=" + AP_PASS + "\r\nWEBSERVER_IP=" + Server_IP.toString() + "\r\nWEBSERVER_PORT=" + String(WEB_PORT) + "\r\nSUBNET_MASK=" + Subnet_Mask.toString() + "\r\nWIFI_SSID=" + WIFI_SSID + "\r\nWIFI_PASS=" + WIFI_PASS + "\r\nWIFI_HOST=" + WIFI_HOSTNAME + "\r\nUSEAP=" + tmpua + "\r\nCONWIFI=" + tmpcw + "\r\nUSBWAIT=" + USB_WAIT + "\r\nESPSLEEP=" + tmpslp + "\r\nSLEEPTIME=" + TIME2SLEEP + "\r\npayload=" + Default_Payload + "\r\nbot_token=" + BOTtoken + "\r\nchat_id=" + CHAT_ID + "\r\nUseTelegram=" + telegram + "\r\nUseTelegramCom=" + botcommands + "\r\nPayloadSleep=" + pysleep + "\r\nRedirect=" + ps_phive + "\r\nRotscreen=" + rotate + "\r\nPSFree=" + psfree + "\r\nbetaGH=" + betaGH);
    iniFile.close();
  }
}

void handleFormat()
{
  //complete wipe, removes all cached files and settings
  if (usefat == true) {
    removeAllFiles();
    ESP.restart();
  }
  else {
    //https://arduino-esp8266.readthedocs.io/en/latest/filesystem.html
    FILESYS.end();
    bool formatted = FILESYS.format();
    if (formatted) {
      ESP.restart();
    }
  }
}

void setup() {
  //SerialPort2.begin(115200, SERIAL_8N1, rxPin, txPin);
  esp_sleep_enable_ext0_wakeup(GPIO_NUM_0,0); //1 = High, 0 = Low
  startMillis = millis();  //initial start time
  start2Millis = millis();  //initial start time
  start3Millis = millis();  //initial start time
  FastLED.addLeds<APA102, LED_DI_PIN, LED_CI_PIN, BGR>(&leds, 1);
  leds = 0x000000; //set onboard led to black (basically the same as turning it off) - in case chip has artefact colour set on boot.
  FastLED.setBrightness(255);
  FastLED.show();

  //set tft screen backlight off during boot, (we can turn it on when we want to use it).
  tft.init();
  tft.setRotation(3);
  tft.fillScreen(TFT_BLACK);
  tft.setSwapBytes(true);
  //tft.pushImage(0, 0,  TFT_W, TFT_H, logo); //added background image
  stext2.setTextWrap(false);  // Don't wrap text to next line
  stext2.setTextSize(3);  // larger letters
  stext2.setTextColor(TFT_GOLD, 0x0000); //RGB foreground, background

  pinMode(TFT_LEDA_PIN, OUTPUT);
  digitalWrite(TFT_LEDA_PIN, 0); //1 for off, 0 for on

  mcuType.toUpperCase(); //string for later display use

  //short click
  button.attachClick([] {
    btn_press = 1;
  });

  //double click
  button.attachDoubleClick([] {
    btn_press = 2;
  });

  //long click
  button.attachLongPressStart([] {
    btn_press = 3;
  });

  //multi click
  button.attachMultiClick([] {
    btn_press = 4;
  });

  if (FILESYS.begin(true)) {

    if (FILESYS.exists("/config.ini")) {
      File iniFile = FILESYS.open("/config.ini", "r");
      if (iniFile) {
        String iniData;
        while (iniFile.available()) {
          char chnk = iniFile.read();
          iniData += chnk;
        }
        iniFile.close();

        if (instr(iniData, "SSID=")) {
          AP_SSID = split(iniData, "SSID=", "\r\n");
          AP_SSID.trim();
        }

        if (instr(iniData, "PASSWORD=")) {
          AP_PASS = split(iniData, "PASSWORD=", "\r\n");
          AP_PASS.trim();
        }

        if (instr(iniData, "WEBSERVER_IP=")) {
          String strwIp = split(iniData, "WEBSERVER_IP=", "\r\n");
          strwIp.trim();
          Server_IP.fromString(strwIp);
        }

        if (instr(iniData, "SUBNET_MASK=")) {
          String strsIp = split(iniData, "SUBNET_MASK=", "\r\n");
          strsIp.trim();
          Subnet_Mask.fromString(strsIp);
        }

        if (instr(iniData, "WIFI_SSID=")) {
          WIFI_SSID = split(iniData, "WIFI_SSID=", "\r\n");
          WIFI_SSID.trim();
        }

        if (instr(iniData, "WIFI_PASS=")) {
          WIFI_PASS = split(iniData, "WIFI_PASS=", "\r\n");
          WIFI_PASS.trim();
        }

        if (instr(iniData, "WIFI_HOST=")) {
          WIFI_HOSTNAME = split(iniData, "WIFI_HOST=", "\r\n");
          WIFI_HOSTNAME.trim();
        }

        if (instr(iniData, "USEAP=")) {
          String strua = split(iniData, "USEAP=", "\r\n");
          strua.trim();
          if (strua.equals("true")) {
            startAP = true;
          } else {
            startAP = false;
          }
        }

        if (instr(iniData, "CONWIFI=")) {
          String strcw = split(iniData, "CONWIFI=", "\r\n");
          strcw.trim();
          if (strcw.equals("true")) {
            connectWifi = true;
          } else {
            connectWifi = false;
          }
        }

        if (instr(iniData, "UseTelegram=")) {
          String tg = split(iniData, "UseTelegram=", "\r\n");
          tg.trim();
          if (tg.equals("true")) {
            UseTG = true;
          } else {
            UseTG = false;
          }
        }

        if (instr(iniData, "UseTelegramCom=")) {
          String tg = split(iniData, "UseTelegramCom=", "\r\n");
          tg.trim();
          if (tg.equals("true")) {
            UseTGBot = true;
          } else {
            UseTGBot = false;
          }
        }

        if (instr(iniData, "USBWAIT=")) {
          strusw = split(iniData, "USBWAIT=", "\r\n");
          strusw.trim();
          USB_WAIT = strusw.toInt();
        }

        if (instr(iniData, "payload=")) {
          Default_Payload = split(iniData, "payload=", "\r\n");
          Default_Payload.trim();
        }

        if (instr(iniData, "payload_name=")) {
          Payload_Name = split(iniData, "payload_name=", "\r\n");
          Payload_Name.trim();
        }

        if (instr(iniData, "ESPSLEEP=")) {
          String strsl = split(iniData, "ESPSLEEP=", "\r\n");
          strsl.trim();
          if (strsl.equals("true")) {
            espSleep = true;
          } else {
            espSleep = false;
          }
        }

        if (instr(iniData, "SLEEPTIME=")) {
          String strslt = split(iniData, "SLEEPTIME=", "\r\n");
          strslt.trim();
          TIME2SLEEP = strslt.toInt();
        }

        if (instr(iniData, "bot_token=")) {
          BOTtoken = split(iniData, "bot_token=", "\r\n");
          BOTtoken.trim();
        }

        if (instr(iniData, "chat_id=")) {
          CHAT_ID = split(iniData, "chat_id=", "\r\n");
          CHAT_ID.trim();
        }

        if (instr(iniData, "PayloadSleep=")) {
          String pydeep = split(iniData, "PayloadSleep=", "\r\n");
          pydeep.trim();
          if (pydeep.equals("true")) {
            sleeponpayload = true;
          } else {
            sleeponpayload = false;
          }
        }

        if (instr(iniData, "Redirect=")) {
          String phive = split(iniData, "Redirect=", "\r\n");
          phive.trim();
          if (phive.equals("true")) {
            psphive = true;
          } else {
            psphive = false;
          }
        }

        if (instr(iniData, "Rotscreen=")) {
          String rot = split(iniData, "Rotscreen=", "\r\n");
          rot.trim();
          if (rot.equals("true")) {
            rotate_lcd = true;
          } else {
            rotate_lcd = false;
          }
        }

        if (instr(iniData, "PSFree=")) {
          String uspsf = split(iniData, "PSFree=", "\r\n");
          uspsf.trim();
          if (uspsf.equals("true")) {
            use_psfree = true;
          } else {
            use_psfree = false;
          }
        }

        if (instr(iniData, "betaGH=")) {
          String usxfh = split(iniData, "betaGH=", "\r\n");
          usxfh.trim();
          if (usxfh.equals("true")) {
            use_beta_goldhen = true;
          } else {
            use_beta_goldhen = false;
          }
        }
      }

    } else {
      writeConfig();
    }
  }

  if (startAP) {
    WiFi.softAPConfig(Server_IP, Server_IP, Subnet_Mask);
    WiFi.softAP(AP_SSID.c_str(), AP_PASS.c_str());
    dnsServer.setTTL(30);
    dnsServer.setErrorReplyCode(DNSReplyCode::ServerFailure);
    dnsServer.start(53, "*", Server_IP);
    ip = Server_IP.toString();
    selfserver = "apmode";
    sid = AP_SSID;
  }

  if (connectWifi && WIFI_SSID.length() > 0 && WIFI_PASS.length() > 0) {
    WiFi.setAutoConnect(true);
    WiFi.setAutoReconnect(true);
    WiFi.hostname(WIFI_HOSTNAME);
    WiFi.begin(WIFI_SSID.c_str(), WIFI_PASS.c_str());
    if (WiFi.waitForConnectResult() != WL_CONNECTED) {} else {
      IPAddress LAN_IP = WiFi.localIP();
      // get time from NPT sever
      timeClient.begin();
      timeClient.setTimeOffset(GMT);
      if (LAN_IP) {
        String mdnsHost = WIFI_HOSTNAME;
        mdnsHost.replace(".local", "");
        MDNS.begin(mdnsHost.c_str());
        if (!startAP) {
          dnsServer.setTTL(30);
          dnsServer.setErrorReplyCode(DNSReplyCode::ServerFailure);
          dnsServer.start(53, "*", LAN_IP);
        }
      }
    }
    ip = WiFi.localIP().toString();
    selfserver = "wifimode";
    sid = WIFI_SSID;
  }

  server.on("/connecttest.txt", HTTP_GET, [](AsyncWebServerRequest * request) {
    request -> send(200, "text/plain", "Microsoft Connect Test");
  });

  server.on("/config.ini", HTTP_ANY, [](AsyncWebServerRequest * request) {
    request -> send(404);
  });

  server.on("/upload.html", HTTP_GET, [](AsyncWebServerRequest * request) {
    AsyncWebServerResponse * response = request -> beginResponse_P(200, "text/html", upload_gz, sizeof(upload_gz));
    response -> addHeader("Content-Encoding", "gzip");
    request -> send(response);
  });

  server.on("/upload.html", HTTP_POST, [](AsyncWebServerRequest * request) {
    request -> redirect("/fileman.html");
  }, handleFileUpload);

  server.on("/fileman.html", HTTP_GET, [](AsyncWebServerRequest * request) {
    handleFileMan(request);
  });

  server.on("/delete", HTTP_POST, [](AsyncWebServerRequest * request) {
    handleDelete(request);
  });

  server.on("/config.html", HTTP_GET, [](AsyncWebServerRequest * request) {
    handleConfigHtml(request);
  });

  server.on("/config.html", HTTP_POST, [](AsyncWebServerRequest * request) {
    handleConfig(request);
  });

  server.on("/admin.html", HTTP_GET, [](AsyncWebServerRequest * request) {
    AsyncWebServerResponse * response = request -> beginResponse_P(200, "text/html", admin_gz, sizeof(admin_gz));
    response -> addHeader("Content-Encoding", "gzip");
    request -> send(response);
  });

  server.on("/reboot.html", HTTP_GET, [](AsyncWebServerRequest * request) {
    AsyncWebServerResponse * response = request -> beginResponse_P(200, "text/html", reboot_gz, sizeof(reboot_gz));
    response -> addHeader("Content-Encoding", "gzip");
    request -> send(response);
  });

  server.on("/rebooting.html", HTTP_POST, [](AsyncWebServerRequest * request) {
    handleReboot(request);
  });

  server.on("/update.html", HTTP_GET, [](AsyncWebServerRequest *request){
    AsyncWebServerResponse *response = request->beginResponse_P(200, "text/html", update_gz, sizeof(update_gz));
    response->addHeader("Content-Encoding", "gzip");
    request->send(response);
  });

  server.on("/update.html", HTTP_POST, [](AsyncWebServerRequest *request){
  }, handleFwUpdate);

  server.on("/info.html", HTTP_GET, [](AsyncWebServerRequest * request) {
    handleInfo(request);
  });

  server.on("/usbon", HTTP_POST, [](AsyncWebServerRequest * request) {
    MountExfatPico();
    request -> send(200, "text/plain", "ok");
  });

  server.on("/usboff", HTTP_POST, [](AsyncWebServerRequest * request) {
    if (usepico){
      dev.end();
      request -> send(200, "text/plain", "ok");
    }
    else {
      ESP.restart();
    }
  });

  server.on("/getnetip", HTTP_POST, [](AsyncWebServerRequest * request) {
    AsyncWebServerResponse *response = request->beginResponse(200, "text/plain", ip);
    request -> send(response);
  });

  server.on("/wifistate", HTTP_POST, [](AsyncWebServerRequest * request) {
    AsyncWebServerResponse *response = request->beginResponse(200, "text/plain", selfserver);
    request -> send(response);
  });

  server.on("/getusbwait", HTTP_POST, [](AsyncWebServerRequest * request) {
    AsyncWebServerResponse *response = request->beginResponse(200, "text/plain", strusw);
    request -> send(response);
  });

  server.on("/payloadinject", HTTP_POST, [](AsyncWebServerRequest * request) {
    payloadinject();
    request -> send(200, "text/plain", "ok");
  });

  server.on("/usbrestart", HTTP_POST, [](AsyncWebServerRequest * request) {
    restartUSB();
    request -> send(200, "text/plain", "ok");
  });

  server.on("/lightsoff", HTTP_POST, [](AsyncWebServerRequest * request) {
     lightsdelay = true; //activate lightsOFF_temp() from main loop
  });

  server.on("/sdcard.html", HTTP_GET, [](AsyncWebServerRequest * request) {
    if (mounted){
      esp_vfs_fat_sdmmc_unmount();
      request -> send(200, "text/html", ("%s", bigstrings[4]));
    }
    else{
      mounted = true;
      request -> send(200, "text/html", ("%s", bigstrings[3]));
      espSleep = false; //don't go to sleep, we could be transferring files....and corrupt the micro sdcard.
      sd_init();
    }
  });

  server.on("/deepsleep", HTTP_POST, [](AsyncWebServerRequest * request) {
    if (sleeponpayload){
      deepsleep();
    }
    request -> send(200, "text/plain", "ok");
  });

  server.on("/format.html", HTTP_GET, [](AsyncWebServerRequest * request) {
    AsyncWebServerResponse * response = request -> beginResponse_P(200, "text/html", format_gz, sizeof(format_gz));
    response -> addHeader("Content-Encoding", "gzip");
    request -> send(response);
  });

  server.on("/format.html", HTTP_POST, [](AsyncWebServerRequest * request) {
    isFormating = true;
    request -> send(304);
  });

  server.on("/wipe", HTTP_GET, [](AsyncWebServerRequest* request) {
    removeAllFiles();
    request->redirect("/fileman.html");
    return;
  });

  server.on("/dlall", HTTP_GET, [](AsyncWebServerRequest * request) {
    handleDlFiles(request);
  });

  server.on("/jzip.js", HTTP_GET, [](AsyncWebServerRequest * request) {
    AsyncWebServerResponse * response = request -> beginResponse_P(200, "text/javascript", jzip_gz, sizeof(jzip_gz));
    response -> addHeader("Content-Encoding", "gzip");
    request -> send(response);
  });

  server.serveStatic("/", FILESYS, "/").setDefaultFile("index.html");

  server.onNotFound([](AsyncWebServerRequest * request) {
    String path = request -> url();
    if (instr(path, "/document/") && instr(path, "/ps4/")) {
      request -> redirect("http://" + WIFI_HOSTNAME + "/index.html");
      return;
    }
    if (path.endsWith("index.html") || path.endsWith("index.htm") || path.endsWith("/")) {
      if (psphive) {
        AsyncWebServerResponse * response = request -> beginResponse_P(200, "text/html", index2_gz, sizeof(index2_gz));
        response -> addHeader("Content-Encoding", "gzip");
        request -> send(response);
      }
      else{
        AsyncWebServerResponse * response = request -> beginResponse_P(200, "text/html", index_gz, sizeof(index_gz));
        response -> addHeader("Content-Encoding", "gzip");
        request -> send(response);
      }
      return;
    }
    if (path.endsWith("style.css")) {
      AsyncWebServerResponse * response = request -> beginResponse_P(200, "text/css", style_gz, sizeof(style_gz));
      response -> addHeader("Content-Encoding", "gzip");
      request -> send(response);
      return;
    }
    if (path.endsWith("payloads.html")) {
      AsyncWebServerResponse * response = request -> beginResponse_P(200, "text/html", payload, sizeof(payload));
      request -> send(response);
      return;
    }
    if (path.endsWith("loader.html")) {
    	if (use_psfree){
    	  AsyncWebServerResponse * response = request -> beginResponse_P(200, "text/html", freeloader_gz, sizeof(freeloader_gz));
    	  response -> addHeader("Content-Encoding", "gzip");
    	  request -> send(response);
    	}
    	else{
    		AsyncWebServerResponse * response = request -> beginResponse_P(200, "text/html", loader_gz, sizeof(loader_gz));
    		response -> addHeader("Content-Encoding", "gzip");
    		request -> send(response);
    	}
      return;
    }

    if (use_psfree){
      if (path.endsWith("exploit.js")) {
        AsyncWebServerResponse * response = request -> beginResponse_P(200, "text/text/javascript", exploit_gz, sizeof(exploit_gz));
        request -> send(response);
        return;
       }
    }


    //use goldhen stored in the sketch
    if (path.endsWith("goldhen.bin"))
    {
      if(use_beta_goldhen){
        AsyncWebServerResponse *response = request->beginResponse_P(200, "application/octet-stream", goldhen, sizeof(goldhen));
        response -> addHeader("Content-Encoding", "gzip");
        request->send(response);
      }
      else{
        AsyncWebServerResponse *response = request->beginResponse_P(200, "application/octet-stream", stable_goldhen, sizeof(stable_goldhen));
        response -> addHeader("Content-Encoding", "gzip");
        request->send(response);
      }
      return;
    }
    request -> send(404);
  });

  DefaultHeaders::Instance().addHeader("Access-Control-Allow-Origin", "*");
  server.begin();
  if (TIME2SLEEP < 5) {
    TIME2SLEEP = 5;
  } //min sleep time
  bootTime = millis();

  if (UseTG && UseTGBot && selfserver == "wifimode"){
    bot.updateToken(String(BOTtoken));
    client.setCACert(TELEGRAM_CERTIFICATE_ROOT); // Add root certificate for api.telegram.org
    bot.sendMessage(CHAT_ID, "Press /start to display the menu options", "");
  }

  else if (UseTG && selfserver == "wifimode"){
    bot.updateToken(String(BOTtoken));
    client.setCACert(TELEGRAM_CERTIFICATE_ROOT); // Add root certificate for api.telegram.org
    bot.sendMessage(CHAT_ID, "PS4 Dongle - http://" + ip + "/admin.html", "");
  }

  scrollfile(); //read string into memory for lcd text.

  //star stuff
  for (uint8_t i = 0; i < STARS; i++){
    initStar(i);
  }

  //create cached files
  donglecache();

  //fire stuff
  XORRand = esp_random();
  makePallets();
  usePalette(1); //1-4

  //lcd rotate
  if (rotate_lcd){
    tft.setRotation(1);
  }
  tft.pushImage(0, 0,  TFT_W, TFT_H, logo); //added background image


  //let's start the unpacker so we can extract our gz files...
  tarGzFS.begin();

  //for some weird reason psfree won't use exploit.js if if's hidden, so let's just make it unhidden for now.
  if (use_psfree){
    if (!FILESYS.exists("/exploitunpacked.js")){
      unpack_exploit();
    }
  }
  else{
    if (FILESYS.exists("/exploit.js")){
      FILESYS.remove("/exploit.js");
    }
    if (FILESYS.exists("/exploitunpacked.js")){
      FILESYS.remove("/exploitunpacked.js");
    }
    if (FILESYS.exists("/loader.html")){
      FILESYS.remove("/loader.html");
    }
  }

  //unpack goldhen to stop the ps4 browser running out of memory and crashing...
  if (!FILESYS.exists("/goldhen.bin")){
    //unpack_goldhen(); //not needed for now, enable if browser has memory issues.
  }
}

void sd_init(void) {
  esp_err_t ret;
  esp_vfs_fat_sdmmc_mount_config_t mount_config = {.format_if_mount_failed = true, .max_files = 5, .allocation_unit_size = 16 * 1024};

  sdmmc_host_t host = {
      .flags = SDMMC_HOST_FLAG_4BIT | SDMMC_HOST_FLAG_DDR,
      .slot = SDMMC_HOST_SLOT_1,
      .max_freq_khz = SDMMC_FREQ_DEFAULT,
      .io_voltage = 3.3f,
      .init = &sdmmc_host_init,
      .set_bus_width = &sdmmc_host_set_bus_width,
      .get_bus_width = &sdmmc_host_get_slot_width,
      .set_bus_ddr_mode = &sdmmc_host_set_bus_ddr_mode,
      .set_card_clk = &sdmmc_host_set_card_clk,
      .do_transaction = &sdmmc_host_do_transaction,
      .deinit = &sdmmc_host_deinit,
      .io_int_enable = sdmmc_host_io_int_enable,
      .io_int_wait = sdmmc_host_io_int_wait,
      .command_timeout_ms = 0,
  };
  sdmmc_slot_config_t slot_config = {
      .clk = (gpio_num_t)SD_MMC_CLK_PIN,
      .cmd = (gpio_num_t)SD_MMC_CMD_PIN,
      .d0 = (gpio_num_t)SD_MMC_D0_PIN,
      .d1 = (gpio_num_t)SD_MMC_D1_PIN,
      .d2 = (gpio_num_t)SD_MMC_D2_PIN,
      .d3 = (gpio_num_t)SD_MMC_D3_PIN,
      .cd = SDMMC_SLOT_NO_CD,
      .wp = SDMMC_SLOT_NO_WP,
      .width = 4, // SDMMC_SLOT_WIDTH_DEFAULT,
      .flags = SDMMC_SLOT_FLAG_INTERNAL_PULLUP,
  };

  gpio_set_pull_mode((gpio_num_t)SD_MMC_CMD_PIN, GPIO_PULLUP_ONLY); // CMD, needed in 4- and 1- line modes
  gpio_set_pull_mode((gpio_num_t)SD_MMC_D0_PIN, GPIO_PULLUP_ONLY);  // D0, needed in 4- and 1-line modes
  gpio_set_pull_mode((gpio_num_t)SD_MMC_D1_PIN, GPIO_PULLUP_ONLY);  // D1, needed in 4-line mode only
  gpio_set_pull_mode((gpio_num_t)SD_MMC_D2_PIN, GPIO_PULLUP_ONLY);  // D2, needed in 4-line mode only
  gpio_set_pull_mode((gpio_num_t)SD_MMC_D3_PIN, GPIO_PULLUP_ONLY);  // D3, needed in 4- and 1-line modes

  ret = esp_vfs_fat_sdmmc_mount(mount_point, &host, &slot_config, &mount_config, &card);

  if (ret != ESP_OK) {
    if (ret == ESP_FAIL) {
      colour_cycle = false;
      leds = 0xff0000; //red
      FastLED.show();
    }
    if (ret == ESP_ERR_INVALID_STATE) {
      colour_cycle = false;
      leds = 0xff0000; //red
      FastLED.show();
    }
  }
  else{
    mountsd();
    colour_cycle = false;
    leds = 0x0000ff; //blue
    FastLED.show();
    //disable screen to prevent overheaing
    scroller = false;
    pinMode(TFT_LEDA_PIN, OUTPUT);
    digitalWrite(TFT_LEDA_PIN, 1); //turn off lcd screen
    mounted = true;
  }
}

static int32_t onWrite(uint32_t lba, uint32_t offset, uint8_t *buffer, uint32_t bufsize) {
  uint32_t count = (bufsize / card->csd.sector_size);
  sdmmc_write_sectors(card, buffer + offset, lba, count);
  return bufsize;
}


static int32_t onReadPico(uint32_t lba, uint32_t offset, void * buffer, uint32_t bufsize) {
  if(usepico){
    if (lba > 4) { lba = 4; }
  }
  else {
    if (lba > 130) { lba = 130; }
  }
  memcpy(buffer, exfathax[lba] + offset, bufsize);
  return bufsize;
}


//popup exfathax - use pico to preserve memory usage
//https://docs.espressif.com/projects/arduino-esp32/en/latest/api/usb_msc.html
void MountExfatPico() {
  dev.vendorID("PS4");
  dev.productID("ESP32 Server");
  dev.productRevision("1.0");
  dev.onRead(onReadPico);
  dev.mediaPresent(true);
  dev.begin(8192, 512); //4MB
  USB.begin();
}

static int32_t onReadsd(uint32_t lba, uint32_t offset, void* buffer, uint32_t bufsize) {
  uint32_t count = (bufsize / card->csd.sector_size);
  sdmmc_read_sectors(card, buffer + offset, lba, count);
  return bufsize;
}

void mountsd() {
  dev.vendorID("LILYGO");       // max 8 chars
  dev.productID("T-Dongle-S3"); // max 16 chars
  dev.productRevision("1.0");   // max 4 chars
  dev.onRead(onReadsd);
  dev.onWrite(onWrite);
  dev.mediaPresent(true);
  dev.begin(card->csd.capacity, card->csd.sector_size);
  USB.begin();
}

void restartUSB() {
  ESP.restart();
}

void deepsleep() {
  pinMode(TFT_LEDA_PIN, OUTPUT);
  digitalWrite(TFT_LEDA_PIN, 1); //turn off lcd screen
  leds = 0x000000; //set onboard led to black - turns them off
  FastLED.setBrightness(0);
  FastLED.show();
  esp_sleep_pd_config(ESP_PD_DOMAIN_RTC_PERIPH, ESP_PD_OPTION_OFF);
  esp_light_sleep_start();
  //esp_deep_sleep_start(); //don't use deep sleep or the lcd backlight will stay on
  return;
}

//after the exploit is complteted and the payload has been sent run this.
void lightsOFF() {
  pinMode(TFT_LEDA_PIN, OUTPUT);
  digitalWrite(TFT_LEDA_PIN, 1); //turn off lcd screen
  leds = 0x000000; //set onboard led to black - turns them off
  FastLED.setBrightness(0);
  FastLED.show();
  if (sleeponpayload){
    dev.end();
    esp_sleep_pd_config(ESP_PD_DOMAIN_RTC_PERIPH, ESP_PD_OPTION_OFF);
    esp_light_sleep_start();
   }
}

void writepage(){
  FILESYS.end();
  FILESYS.begin();
  String strusw;
  //read the config again because it's been updated....
  if (FILESYS.exists("/config.ini")) {
      File iniFile = FILESYS.open("/config.ini", "r");
      if (iniFile) {
        String iniData;
        while (iniFile.available()) {
          char chnk = iniFile.read();
          iniData += chnk;
        }
        iniFile.close();

        if (instr(iniData, "payload=")) {
          Default_Payload = split(iniData, "payload=", "\r\n");
          Default_Payload.trim();
        }

        if (instr(iniData, "payload_name=")) {
          Payload_Name = split(iniData, "payload_name=", "\r\n");
          Payload_Name.trim();
        }

        if (instr(iniData, "USBWAIT=")) {
          strusw = split(iniData, "USBWAIT=", "\r\n");
          strusw.trim();
        }
      }
   }
  //end of reading the bit of the config we care about.

  String filename = "/payloads.html";
  bool file_exists = FILESYS.exists(filename);
  if (file_exists) {
    FILESYS.remove(filename);
  }

  //write payload html page to buffer.
  char buffer[sizeof(payload)];
  memcpy(buffer, payload, sizeof(payload));

  //convert the above array to a string
  unsigned int a_size = sizeof(buffer) / sizeof(char);
  String s_a = convertToString(buffer, a_size);

  //replace part of string
  s_a.replace("goldhen.bin", Default_Payload); //don't change unless you also mod pages.h/payload
  s_a.replace("GoldHEN", Payload_Name); //don't change unless you also mod pages.h/payload
  s_a.replace("3000", strusw); //don't change unless you also mod pages.h/payload

  //write modded string to a file
  File newfile = FILESYS.open(filename, "w");
  newfile.print(s_a);
  newfile.close();
}

String convertToString(char* a, unsigned int size)
{
    unsigned int i;
    String s = "";
    for (i = 0; i < size; i++) {
        s = s + a[i];
    }
    return s;
}

void colourcycle(){
  uint8_t period = 60;
  currentMillis = millis();  //get the current "time" (actually the number of milliseconds since the program started)
  if (currentMillis - startMillis >= period)  //test whether the period has elapsed
  {
    static uint8_t hue = 0;
    leds = CHSV(hue++, 0XFF, 100);
    FastLED.show();
    startMillis = currentMillis;  //IMPORTANT to save the start time of the current LED state.
  }
}

void blinkled(){
  currentMillis = millis();
  int delaytime = (currentMillis/350);
  if(delaytime % 2 == 0)leds = 0xff0000; //red
  if(delaytime % 2 > 0)leds = 0x0000ff; //blue
  FastLED.show();
}

void reinstall() {
  File file = FILESYS.open("/Reset-triggered.txt", "w");
  file.printf("%s", bigstrings[2]);
  file.close();
}

//let's unpack goldhen on the dongle to help stop the ps4 browser running out of memory and crashing...
void unpack_goldhen(){
  File file = FILESYS.open("/goldhen.temp", "wb");
  unsigned char buffer[1];
  unsigned int goldsize = sizeof(goldhen);
  for (unsigned int i = 0; i < goldsize; i++) {
    memcpy(buffer, goldhen + i, 1);
    file.write(buffer, 1);
  }
  file.close();
  //now we write this temp file to the dongle we can unpack it now....
  GzUnpacker *GZUnpacker = new GzUnpacker();
  GZUnpacker->haltOnError(true); // stop on fail (manual restart/reset required)
  GZUnpacker->gzExpander(tarGzFS, "/goldhen.temp", tarGzFS, "/goldhen.bin");
  //now remove our temp file...
  if (FILESYS.exists("/goldhen.temp")){
    FILESYS.remove("/goldhen.temp");
  }
}

void unpack_exploit(){
  File file = FILESYS.open("/exploit.js", "w");  //ab for append binary
  unsigned char buffer[1];
  unsigned int goldsize = sizeof(exploit_gz);
  for (unsigned int i = 0; i < goldsize; i++) {
    memcpy(buffer, exploit_gz + i, 1);
    file.write(buffer, 1);
  }
  file.close();
  //also probably we should unpack the loader as well...
  file = FILESYS.open("/packedloader.html", "w");  //ab for append binary
  goldsize = sizeof(freeloader_gz);
  for (unsigned int i = 0; i < goldsize; i++) {
    memcpy(buffer, freeloader_gz + i, 1);
    file.write(buffer, 1);
  }
  file.close();
  //copying is done at this point...
  //if file is gz packed we should unpack it now - https://github.com/tobozo/ESP32-targz
  GzUnpacker *GZUnpacker = new GzUnpacker();
  GZUnpacker->haltOnError(true); // stop on fail (manual restart/reset required)
  GZUnpacker->gzExpander(tarGzFS, "/exploit.js", tarGzFS, "/exploitunpacked.js");
  GZUnpacker->gzExpander(tarGzFS, "/packedloader.html", tarGzFS, "/loader.html");

  //now remove the packed exploit
  if (FILESYS.exists("/exploit.js")){
    FILESYS.remove("/exploit.js");
  }
  if (FILESYS.exists("/packedloader.html")){
    FILESYS.remove("/packedloader.html");
  }
}

void hardreset(){
  //display red led and set led screen red
  tft.fillScreen(TFT_RED);
  tft.setTextColor(0xFFFF, TFT_RED); //RGB foreground, background
  tft.setTextSize(2);
  tft.setCursor(12, 15); //x,y
  tft.println("Please Wait");
  tft.setCursor(18, 33); //x,y
  tft.println("Hard Reset");
  tft.setCursor(22, 51); //x,y
  tft.println("Triggered");
  FastLED.setBrightness(255);
  leds = 0xff0000; //red
  FastLED.show();
}

void configreset(){
  //display red led and set led screen red
  tft.fillScreen(TFT_RED);
  tft.setTextColor(0xFFFF, TFT_RED); //RGB foreground, background
  tft.setTextSize(2);
  tft.setCursor(12, 15); //x,y
  tft.println("Please Wait");
  tft.setCursor(8, 33); //x,y
  tft.println("Config Reset");
  tft.setCursor(22, 51); //x,y
  tft.println("Triggered");
  FastLED.setBrightness(255);
  leds = 0xff0000; //red
  FastLED.show();
}

void scrollfile(){
  File file = FILESYS.open("/scroll.txt", FILE_READ);
  if (file){
    lcdscroller[0] = file.readString();
    file.close();
  }
  else {
    String blank = " **** ";
    if (selfserver == "wifimode"){
      //get time from NPT server
      while(!timeClient.update()) {
        timeClient.forceUpdate();
      }
      formattedDate = timeClient.getFormattedTime();
      // Extract date
      int splitT = formattedDate.indexOf("T");
      dayStamp = formattedDate.substring(0, splitT);
      timeStamp = formattedDate.substring(splitT+1, formattedDate.length()-1);
      lcdscroller[0] = "Current Time:" + timeStamp + " (" + dayStamp + ")" + blank;
     }
    String x = String(compile_date);
    x.replace("  "," ");
    x.replace(" ","-");
    x.replace("2023","23");
    lcdscroller[0] += "SSID:" + sid + blank + "IP:" + ip + blank + "MAC:" + MacAddress() + blank + "CHIP:" + mcuType + blank + "Coded By MrDude" + blank + "Compiled:" + x + " ***";
  }
}

void scrolltext(){
  uint16_t arraysize = lcdscroller[0].length() + 1; // Length (with one extra character for the null terminator)
  char textarray[arraysize]; // Prepare the character array (the buffer)
  lcdscroller[0].toCharArray(textarray, arraysize); // Copy it over
  uint8_t fontwidth = (16); //font width

  if (arraypos >= arraysize){
    arraypos = 0;
  }
  if (changecol >= arraysize){
    changecol = 0;
    swap_routine++;
    // change the starfield effect so we don't get bored.
    jump++;
    if (jump > 1){
      //jump = 1;
      lcdscroller[0] = "Why are you still reading this?";
      lcdscroller[0] += " Greetings to the following GBATemp members *** peteruk *** laz305 *** bigking94 *** snoopy75 *** pucky70 *** zazo *** ";
      lcdscroller[0] += "and for the rest *** have a nice day :-) ***";
    }
    else{
      scrollfile();
    }
    uint8_t val = random(0, (sizeof(randrange)/sizeof(randrange[0])-1)); //calculate size of array and pick a random value
    stext2.setTextColor(randrange[val], 0x0000); //random min/max - background black

    if (swap_routine == 1){
      routine = 1; //jump to scrolltext2
    }
    if (swap_routine > 2){
      //swap_routine = 0; //reset swap routine
      //routine = 1; //jump to scrolltext2
      fire_effect = true;
    }
  }

  stext2.createSprite(TFT_W+fontwidth, 32); // Sprite wider than the display plus the text width.
  if (nowMillis - start2Millis >= 25)
  {
    stext2.pushSprite(0, scroll_loc); //location to put the scrolling text
    stext2.scroll(-1); // scroll stext 1 pixel left, up/down default is 0

    tcount--;
    if (tcount <=0)
    {
      char x = textarray[arraypos];
      tcount = fontwidth; //once this pixel count is reached redraw the text
      stext2.drawString(String(x), TFT_W, 0, 1);
      arraypos++;
      changecol++;
    }
    start2Millis = nowMillis;
  }
}

void payloadinject(){
  //show when the payload is being loaded
  colour_cycle = false;
  blink_led = false;
  leds = CRGB::Green;
  FastLED.show();
}

void resetconfig() {
  FILESYS.remove("/config.ini");
  FILESYS.remove("/payloads.html");
  resetconf = true;
}

//use this code if fat is selected instead of spiffs
void removeAllFiles(){
  File dir = FILESYS.open("/");
  while (dir) {
    File file = dir.openNextFile();
    if (!file) {
      dir.close();
      break;
    }
    String fname = String(file.name());
    if (fname.length() > 0) {
      file.close();
      FILESYS.remove("/" + fname);
    }
  }
}

void handle_message(){
  for (uint8_t i=0; i<numNewMessages; i++) {
    // Chat id of the requester
    String text = "";
    String chat_id = String(bot.messages[i].chat_id);
    if (chat_id != CHAT_ID){
      bot.sendMessage(chat_id, "Unauthorized user", "");
      continue;
    }

    // Print the received message
    if (message_status == 1){
      text = bot.messages[i].text;
      message_status = 0;
    }

    //https://github.com/witnessmenow/Universal-Arduino-Telegram-Bot/issues/38

    if (text == "/start" || text == "/help" ) {
      String welcome = "PS4 dongle commands.\n";
      welcome += "/help - Show this help menu.\n";
      welcome += "/ip - Show the dongle's IP address.\n";
      welcome += "/config - Link to the web config page.\n";
      welcome += "/mac - Show the dongle's MAC address.\n";
      welcome += "/sleep - Put the dongle into sleep mode.\n";
      welcome += "/restart - Restart the dongle.\n";
      welcome += "/reset - Remove the dongle's config files.\n";
      welcome += "/erase - Wipe clean the dongle's fat partition.\n";
      bot.sendMessage(chat_id, welcome, "");
      welcome = ""; //clear this now as we already sent the message..
    }

    else if (text == "/mac") {
      bot.sendMessage(chat_id, "MAC: " + MacAddress(), "");
    }

    else if (text == "/ip") {
      bot.sendMessage(CHAT_ID, ip, "");
    }

    else if (text == "/config") {
      bot.sendMessage(CHAT_ID, "Dongle config - http://" + ip + "/config.html", "");
    }

    else if (text == "/restart") {
      bot.sendMessage(chat_id, "Restart commencing", "");
      ESP.restart();
    }

    else if (text == "/reset") {
      bot.sendMessage(chat_id, "Defaults reset - (AP mode reactivated),", "");
      hardreset(); //show visual warning
      resetconfig();
    }

    else if (text == "/sleep") {
      bot.sendMessage(chat_id, "Dongle shutdown activated", "");
      deepsleep();
    }

    else if (text == "/erase") {
      bot.sendMessage(chat_id, "Erase fat partition (AP mode reactivated)", "");
      hardreset(); //show visual warning
      handleFormat();
    }
    else{
      if (text != ""){
        bot.sendMessage(chat_id, text + " is not a valid command. Press /help for the menu", "");
      }
    }
  }
}

void check_messages(){
    numNewMessages = bot.getUpdates(bot.last_message_received +1);
    if(numNewMessages >=1) {
      handle_message();
      message_status = 1;
    }
    lastTimeBotRan = nowMillis;
}

void botmode(){
  tft.fillScreen(0x7826);
  tft.setTextColor(0xFFFF, TFT_WHITE); //RGB foreground, background
  tft.setTextSize(2);

  //centre the text
  String bm = "Bot Mode";
  int8_t bml = (TFT_W/2 - ((bm.length()/2)*12));
  String en = "Enabled";
  int8_t enl = (TFT_W/2 - ((en.length()/2)*12));
  int8_t ipl = (TFT_W/2 - ((ip.length()/2)*12));

  tft.setCursor(bml, 8); //x,y
  tft.println(bm);
  tft.setCursor(enl-8, 32); //x,y
  tft.println(en);
  tft.setCursor(ipl, 56); //x,y
  tft.println(ip);
}

void startest(){
  scrolltext();
  nowMillis = millis();  //get the current "time" (the number of milliseconds since the program started)
  if (nowMillis - start3Millis >= 60)
  {
    tft.fillRect(0, 0, TFT_W, scroll_loc, TFT_BLACK); //fill the top section of the screen before the text sprite
    tft.fillRect(0, scroll_loc+32, TFT_W, TFT_H-(scroll_loc+32), TFT_BLACK); //fill the bottom section of the screen after the text sprite (32 is the height of the font)
    showStarfield();
    start3Millis = nowMillis;
  }
}

void initStar(int i) {
  star_x[i] = random(-TFT_W, TFT_W);
  star_y[i] = random(-TFT_H, TFT_H);
  star_z[i] = random(100, 250);
}

void showStarfield() {
  int8_t centrex,centrey;
  centrex = TFT_W / 2;
  centrey = TFT_H / 2;
  int16_t colour = random(0xF940, 0xFF40);
  int16_t colour2 = random(0x07E0, 0x07FD);
  for (int8_t i = 0; i < STARS; i++) {
    star_z[i] = star_z[i]-8;
    starx = star_x[i] / star_z[i] * 100 + centrex;
    stary = star_y[i] / star_z[i] * 100 + centrey;
    if((starx < 0) || (starx > TFT_W) || (stary < 0) || (stary > TFT_H) || (star_z[i] < 1)) {
      initStar(i);
    }
    if (jump == 1)
      tft.drawRect(starx+14, stary, 12, 8, colour);
    else if (jump == 2)
      tft.drawCircle(starx+18, stary, 2, colour);
    else{
      jump = 1;
    }
  }
}

void donglecache(){
  if (!FILESYS.exists("/dongle.cache")){
    File file = FILESYS.open("/dongle.cache", "w");
    //file.printf("%s%s%s%s%s%s%s%s%s%s", s0, s1, s2, s3, s4, s5, s6, s7, s8, s9);
    file.printf("%s%s%s%s%s%s%s%s", s0, s1, s2, s5, s6, s7, s8, s9);
    file.close();
  }
}

float random2(){
  XORRand ^= XORRand << 13;
  XORRand ^= XORRand >> 17;
  XORRand ^= XORRand << 5;
  return (float)((float)XORRand * 2.32830643653869628906e-010f);
}

void makePallets(){
  for (int i = 0; i < 64; i++){
    uint8_t r = i * 4;
    uint8_t g = 0;
    uint8_t b = 0;
    color[200 + i] = ((g & 0b00011100) << 11) | ((g & 0b11100000) >> 5) | ((b & 0b11111000) << 5) | ((r & 0b11111000));
    r = 255;
    g = i * 4;
    b = 0;
    color[200 + i + 64] = ((g & 0b00011100) << 11) | ((g & 0b11100000) >> 5) | ((b & 0b11111000) << 5) | ((r & 0b11111000));
    r = 255;
    g = 255;
    b = i * 2;
    color[200 + i + 128] = ((g & 0b00011100) << 11) | ((g & 0b11100000) >> 5) | ((b & 0b11111000) << 5) | ((r & 0b11111000));
  }
}

void usePalette(uint8_t pal){
  uint16_t palOffset = pal * 200;
  for(uint16_t i = 0; i < 200; i++){
    color[i] = color[palOffset + i];
  }
}

void fire(){
  // Heat up the bottom of the fire.
  for (uint16_t i = 16384; i < 16384 + TFT_W; i++) {
    matrix[i] = 300.0f * random2();
  }
  // Nasty floating point maths to produce the billowing and nice blending.
  for (uint16_t i = 0; i < 16384; i++) {
    uint16_t pixel = (float)i + TFT_W - random2() + 0.8f;
    float sum = matrix[pixel] + matrix[pixel + 1] + matrix[pixel - TFT_W] + matrix[pixel - TFT_W + 1];
    uint16_t value = sum * 0.49f * random2() + 0.5f;
    matrix[i] = value;
    if(value > 199) value = 199;
    backBuffer565[i] = color[value];
  }
  backBuffer565[0] = 0;
  backBuffer565[1] = 0;
  backBuffer565[2] = 0;
  backBuffer565[3] = 0;
  tft.pushImage(0, 0, TFT_W, TFT_H, backBuffer565, 80);
}
void offlights(){
  colour_cycle = false; //don't get stuck in a loop
  scroller = false;
  lightsdelay = false; //don't get stuck in a loop
  lightsOFF();
}

void loop() {
  button.tick();
  //SerialPort2.print("this is a test\n");
  //set a delay after payload injection to turn off lights or deepsleep
  if (lightsdelay){
    offlights();
  }

  //short button click -button will always be set to 1 unless we reset it to 0 somehow, so will always be in a loop.
  if (btn_press == 1) {
    if (mounted){
      esp_vfs_fat_sdcard_unmount(mount_point, card);
    }
    else{
      espSleep = false; //don't go to sleep, we could be transferring files....and corrupt the micro sdcard.
      sd_init();
    }
    btn_press = 0; //don't get stuck in a loop :-)
  }

  //double button click - reboot esp
  if (btn_press == 2) {
    ESP.restart();
  }

  //long button click - trigger file wipe (clean fat or spiffs partition)
  if (btn_press == 3) {
    if (hardformat) {
      hardreset(); //show visual warning
      hardformat = false;
      FILESYS.end();
      boolean done = FILESYS.format();
      if(done){
        ESP.restart(); //reboot esp
      }
    }
  }

  //multi click - trigger config reset (just remove config files)
  if (btn_press == 4) {
    configreset(); //show visual warning
    resetconfig();
    if (resetconf == true) {
      if (installgoldhen == true) {
        reinstall(); //reinstall goldhen before rebooting
      }
    }
    ESP.restart(); //reboot esp
  }

  if (espSleep) {
    if (millis() >= (bootTime + (TIME2SLEEP * 60000))) {
      deepsleep();
    }
  }
  if (isFormating == true) {
    handleFormat();
  }
  dnsServer.processNextRequest();

  if (colour_cycle == true){
    FastLED.setBrightness(130);
    colourcycle(); //start onboard led colour cycle
  }

  if (blink_led == true){
    FastLED.setBrightness(255);
    blinkled(); //start blinking onboard led
  }

  if (scroller == true){
    switch (routine) {
      case 0:
        scrolltext();
        break;
      case 1:
        startest();
        break;
     }
  }

  if (fire_effect == true){
    tft.setSwapBytes(false);
    scroller = false;
    fire();
  }

  nowMillis = millis();  //get the current "time" (actually the number of milliseconds since the program started)

  if ((UseTG == true) && (selfserver == "wifimode") && (nowMillis > lastTimeBotRan + botRequestDelay) && (UseTGBot == true)){
    scroller = false;
    runonce=false;
    if (Bot_mode == 1){
      botmode();
      Bot_mode = 0; //change because we don't need to run this more than once.
    }
    check_messages();
  }

  if (UseTGBot == false || selfserver != "wifimode" ){
    if (runonce == true){
      if (nowMillis > (4 * 1000)) { //4 is the amount of seconds to display the start logo
        tft.setTextSize(1);
        tft.fillScreen(TFT_BLACK);
        tft.fillRect(0, 0, TFT_W, 6, 0xF800); //red
        tft.fillRect(0, 6, TFT_W, 6, 0xFFFF); //white
        tft.fillRect(0, 12, TFT_W, 6, 0x001F); //blue
        tft.fillRect(0, 74, TFT_W, 6, 0xF800); //red
        tft.fillRect(0, 68, TFT_W, 6, 0xFFFF); //white
        tft.fillRect(0, 62, TFT_W, 6, 0x001F); //blue
        tft.setTextColor(0xFFFF);
        tft.setCursor(13, 10); //x,y
        scroller = true; //enable scrolling text on the tft screen
        runonce=false; //don't change - we only need this code to run once...
      }
    }
  }
}
